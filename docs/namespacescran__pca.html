<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>scran_pca: scran_pca Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">scran_pca
   </div>
   <div id="projectbrief">PCA for single-cell data</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">scran_pca Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Principal component analysis on single-cell data.  
<a href="namespacescran__pca.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__pca_1_1BlockedPcaOptions.html">BlockedPcaOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="namespacescran__pca.html#ac0670ebef2b278df686dee3735a3184e">blocked_pca()</a></code>.  <a href="structscran__pca_1_1BlockedPcaOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__pca_1_1BlockedPcaResults.html">BlockedPcaResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of <code><a class="el" href="namespacescran__pca.html#ac0670ebef2b278df686dee3735a3184e">blocked_pca()</a></code>.  <a href="structscran__pca_1_1BlockedPcaResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__pca_1_1SimplePcaOptions.html">SimplePcaOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Options for <code><a class="el" href="namespacescran__pca.html#a8bb03efc0b17f40914481039ec1f25c0">simple_pca()</a></code>.  <a href="structscran__pca_1_1SimplePcaOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscran__pca_1_1SimplePcaResults.html">SimplePcaResults</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Results of <code><a class="el" href="namespacescran__pca.html#a8bb03efc0b17f40914481039ec1f25c0">simple_pca()</a></code>.  <a href="structscran__pca_1_1SimplePcaResults.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8bb03efc0b17f40914481039ec1f25c0" id="r_a8bb03efc0b17f40914481039ec1f25c0"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename EigenMatrix_ , class EigenVector_ &gt; </td></tr>
<tr class="memitem:a8bb03efc0b17f40914481039ec1f25c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__pca.html#a8bb03efc0b17f40914481039ec1f25c0">simple_pca</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;mat, int rank, const <a class="el" href="structscran__pca_1_1SimplePcaOptions.html">SimplePcaOptions</a> &amp;options, <a class="el" href="structscran__pca_1_1SimplePcaResults.html">SimplePcaResults</a>&lt; EigenMatrix_, EigenVector_ &gt; &amp;output)</td></tr>
<tr class="separator:a8bb03efc0b17f40914481039ec1f25c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0d71c595c8659a0167dd11fe5f86ff" id="r_a0c0d71c595c8659a0167dd11fe5f86ff"><td class="memTemplParams" colspan="2">template&lt;typename EigenMatrix_  = Eigen::MatrixXd, class EigenVector_  = Eigen::VectorXd, typename Value_ , typename Index_ &gt; </td></tr>
<tr class="memitem:a0c0d71c595c8659a0167dd11fe5f86ff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__pca_1_1SimplePcaResults.html">SimplePcaResults</a>&lt; EigenMatrix_, EigenVector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__pca.html#a0c0d71c595c8659a0167dd11fe5f86ff">simple_pca</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;mat, int rank, const <a class="el" href="structscran__pca_1_1SimplePcaOptions.html">SimplePcaOptions</a> &amp;options)</td></tr>
<tr class="separator:a0c0d71c595c8659a0167dd11fe5f86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0670ebef2b278df686dee3735a3184e" id="r_ac0670ebef2b278df686dee3735a3184e"><td class="memTemplParams" colspan="2">template&lt;typename Value_ , typename Index_ , typename Block_ , typename EigenMatrix_ , class EigenVector_ &gt; </td></tr>
<tr class="memitem:ac0670ebef2b278df686dee3735a3184e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__pca.html#ac0670ebef2b278df686dee3735a3184e">blocked_pca</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;mat, const Block_ *block, int rank, const <a class="el" href="structscran__pca_1_1BlockedPcaOptions.html">BlockedPcaOptions</a> &amp;options, <a class="el" href="structscran__pca_1_1BlockedPcaResults.html">BlockedPcaResults</a>&lt; EigenMatrix_, EigenVector_ &gt; &amp;output)</td></tr>
<tr class="separator:ac0670ebef2b278df686dee3735a3184e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afda11648e2deef18a0044e7e960c5d8d" id="r_afda11648e2deef18a0044e7e960c5d8d"><td class="memTemplParams" colspan="2">template&lt;typename EigenMatrix_  = Eigen::MatrixXd, class EigenVector_  = Eigen::VectorXd, typename Value_ , typename Index_ , typename Block_ &gt; </td></tr>
<tr class="memitem:afda11648e2deef18a0044e7e960c5d8d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structscran__pca_1_1BlockedPcaResults.html">BlockedPcaResults</a>&lt; EigenMatrix_, EigenVector_ &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacescran__pca.html#afda11648e2deef18a0044e7e960c5d8d">blocked_pca</a> (const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;mat, const Block_ *block, int rank, const <a class="el" href="structscran__pca_1_1BlockedPcaOptions.html">BlockedPcaOptions</a> &amp;options)</td></tr>
<tr class="separator:afda11648e2deef18a0044e7e960c5d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Principal component analysis on single-cell data. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="afda11648e2deef18a0044e7e960c5d8d" name="afda11648e2deef18a0044e7e960c5d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afda11648e2deef18a0044e7e960c5d8d">&#9670;&#160;</a></span>blocked_pca() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EigenMatrix_  = Eigen::MatrixXd, class EigenVector_  = Eigen::VectorXd, typename Value_ , typename Index_ , typename Block_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__pca_1_1BlockedPcaResults.html">BlockedPcaResults</a>&lt; EigenMatrix_, EigenVector_ &gt; scran_pca::blocked_pca </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__pca_1_1BlockedPcaOptions.html">BlockedPcaOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="namespacescran__pca.html#ac0670ebef2b278df686dee3735a3184e">blocked_pca()</a></code> that allocates memory for the output.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EigenMatrix_</td><td>A floating-point <code>Eigen::Matrix</code> class. </td></tr>
    <tr><td class="paramname">EigenVector_</td><td>A floating-point <code>Eigen::Vector</code> class. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix data. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type for the blocking factor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Input expression matrix. Columns should contain cells while rows should contain genes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of cells, containing the block assignment for each cell. Each assignment should be an integer in <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[0, N)$" src="form_0.png"/></picture> where <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> is the number of blocks. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rank</td><td>Number of PCs to compute. This should be no greater than the maximum number of PCs, i.e., the smaller dimension of the input matrix; otherwise, only the maximum number of PCs will be reported in the results. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results of the PCA on the residuals. </dd></dl>

</div>
</div>
<a id="ac0670ebef2b278df686dee3735a3184e" name="ac0670ebef2b278df686dee3735a3184e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0670ebef2b278df686dee3735a3184e">&#9670;&#160;</a></span>blocked_pca() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename Block_ , typename EigenMatrix_ , class EigenVector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_pca::blocked_pca </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Block_ *&#160;</td>
          <td class="paramname"><em>block</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__pca_1_1BlockedPcaOptions.html">BlockedPcaOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__pca_1_1BlockedPcaResults.html">BlockedPcaResults</a>&lt; EigenMatrix_, EigenVector_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In the presence of a blocking factor (e.g., batches, samples), we want to ensure that the PCA is not driven by uninteresting differences between blocks. To achieve this, <code><a class="el" href="namespacescran__pca.html#ac0670ebef2b278df686dee3735a3184e">blocked_pca()</a></code> centers the expression of each gene in each blocking level and uses the residuals for PCA. The gene-gene covariance matrix will thus focus on variation within each batch, ensuring that the top rotation vectors/principal components capture biological heterogeneity instead of inter-block differences. Internally, <code><a class="el" href="namespacescran__pca.html#ac0670ebef2b278df686dee3735a3184e">blocked_pca()</a></code> defers the residual calculation until the matrix multiplication steps within <a href="https://github.com/LTLA/CppIrlba">IRLBA</a>. This yields the same results as the naive calculation of residuals but is much faster as it can take advantage of efficient sparse operations.</p>
<p>By default, the principal components are computed from the (conceptual) matrix of residuals. This yields a low-dimensional space where all inter-block differences have been removed, assuming that all blocks have the same composition and the inter-block differences are consistent for all cell subpopulations. Under these assumptions, we could use these components for downstream analysis without any concern for block-wise effects. In practice, these assumptions do not hold and more sophisticated batch correction methods like <a href="https://github.com/LTLA/CppMnnCorrect">MNN correction</a> are required. Some of these methods accept a low-dimensional embedding of cells as input, which can be created by <code><a class="el" href="namespacescran__pca.html#ac0670ebef2b278df686dee3735a3184e">blocked_pca()</a></code> with <code><a class="el" href="structscran__pca_1_1BlockedPcaOptions.html#a3e2503517358ed97e08dc9111e35e791">BlockedPcaOptions::components_from_residuals</a> = false</code>. In this mode, only the rotation vectors are computed from the residuals. The original expression values for each cell are then projected onto the associated subspace to obtain PC coordinates that can be used for further batch correction. This approach aims to preserve the benefits of blocking to focus on intra-block biology instead of inter-block differences, without making strong assumptions about the nature of those differences.</p>
<p>If one batch has many more cells than the others, it will dominate the PCA by driving the axes of maximum variance. This may mask interesting aspects of variation in the smaller batches. To mitigate this, we scale each batch in inverse proportion to its size (see <code><a class="el" href="structscran__pca_1_1BlockedPcaOptions.html#aa5ac168e8a3384d0fde25a966db0bdac">BlockedPcaOptions::block_weight_policy</a></code>). This ensures that each batch contributes equally to the (conceptual) gene-gene covariance matrix and thus the rotation vectors. The vector of residuals for each cell (or the original expression values, if <code><a class="el" href="structscran__pca_1_1BlockedPcaOptions.html#a3e2503517358ed97e08dc9111e35e791">BlockedPcaOptions::components_from_residuals</a> = false</code>) is then projected to the subspace defined by these rotation vectors to obtain that cell's PC coordinates.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix data. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">Block_</td><td>Integer type for the blocking factor. </td></tr>
    <tr><td class="paramname">EigenMatrix_</td><td>A floating-point <code>Eigen::Matrix</code> class. </td></tr>
    <tr><td class="paramname">EigenVector_</td><td>A floating-point <code>Eigen::Vector</code> class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>Input expression matrix. Columns should contain cells while rows should contain genes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">block</td><td>Pointer to an array of length equal to the number of cells, containing the block assignment for each cell. Each assignment should be an integer in <picture><source srcset="form_0_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$[0, N)$" src="form_0.png"/></picture> where <picture><source srcset="form_1_dark.png" media="(prefers-color-scheme: dark)"/><img class="formulaInl" alt="$N$" src="form_1.png"/></picture> is the number of blocks. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rank</td><td>Number of PCs to compute. This should be no greater than the maximum number of PCs, i.e., the smaller dimension of the input matrix; otherwise, only the maximum number of PCs will be reported in the results. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, the results of the PCA on the residuals. This can be re-used across multiple calls to <code><a class="el" href="namespacescran__pca.html#ac0670ebef2b278df686dee3735a3184e">blocked_pca()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0c0d71c595c8659a0167dd11fe5f86ff" name="a0c0d71c595c8659a0167dd11fe5f86ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0d71c595c8659a0167dd11fe5f86ff">&#9670;&#160;</a></span>simple_pca() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename EigenMatrix_  = Eigen::MatrixXd, class EigenVector_  = Eigen::VectorXd, typename Value_ , typename Index_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscran__pca_1_1SimplePcaResults.html">SimplePcaResults</a>&lt; EigenMatrix_, EigenVector_ &gt; scran_pca::simple_pca </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__pca_1_1SimplePcaOptions.html">SimplePcaOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overload of <code><a class="el" href="namespacescran__pca.html#a8bb03efc0b17f40914481039ec1f25c0">simple_pca()</a></code> that allocates memory for the output.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">EigenMatrix_</td><td>A floating-point <code>Eigen::Matrix</code> class. </td></tr>
    <tr><td class="paramname">EigenVector_</td><td>A floating-point <code>Eigen::Vector</code> class. </td></tr>
    <tr><td class="paramname">Value_</td><td>Type of the matrix data. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>The input expression matrix. Columns should contain cells while rows should contain genes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rank</td><td>Number of PCs to compute. This should be no greater than the maximum number of PCs, i.e., the smaller dimension of the input matrix; otherwise, only the maximum number of PCs will be reported in the results. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Results of the PCA. </dd></dl>

</div>
</div>
<a id="a8bb03efc0b17f40914481039ec1f25c0" name="a8bb03efc0b17f40914481039ec1f25c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb03efc0b17f40914481039ec1f25c0">&#9670;&#160;</a></span>simple_pca() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Value_ , typename Index_ , typename EigenMatrix_ , class EigenVector_ &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void scran_pca::simple_pca </td>
          <td>(</td>
          <td class="paramtype">const <a class="elRef" href="https://tatami-inc.github.io/tatami/classtatami_1_1Matrix.html">tatami::Matrix</a>&lt; Value_, Index_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>mat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structscran__pca_1_1SimplePcaOptions.html">SimplePcaOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscran__pca_1_1SimplePcaResults.html">SimplePcaResults</a>&lt; EigenMatrix_, EigenVector_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Principal components analysis (PCA) is a helpful technique for data compression and denoising. The idea is that the earlier PCs capture most of the systematic biological variation while the later PCs capture random technical noise. Thus, we can reduce the size of the data and eliminate noise by only using the earlier PCs for further analyses. Most practitioners will keep the first 10-50 PCs, though the exact choice is fairly arbitrary. *</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Value_</td><td>Type of the matrix data. </td></tr>
    <tr><td class="paramname">Index_</td><td>Integer type for the indices. </td></tr>
    <tr><td class="paramname">EigenMatrix_</td><td>A floating-point <code>Eigen::Matrix</code> class. </td></tr>
    <tr><td class="paramname">EigenVector_</td><td>A floating-point <code>Eigen::Vector</code> class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mat</td><td>The input expression matrix. Columns should contain cells while rows should contain genes. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">rank</td><td>Number of PCs to compute. This should be no greater than the maximum number of PCs, i.e., the smaller dimension of the input matrix; otherwise, only the maximum number of PCs will be reported in the results. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">options</td><td>Further options. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>On output, the results of the PCA on <code>mat</code>. This can be re-used across multiple calls to <code><a class="el" href="namespacescran__pca.html#a8bb03efc0b17f40914481039ec1f25c0">simple_pca()</a></code>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
